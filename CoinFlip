pragma solidity ^0.4.2;
contract CoinFlip {

// Holds the final outcome. Odd for tails, even for heads. 
bool public result;


// Current flip 
uint public commitPhaseEndTime;
uint public pot = 0;


struct player {
// Players choice hashed with their password 
bytes32 _betCommit;
// The revealed bet choice 
bool choice;
// true is revealed
bool betStatus;
}

// Map addresses to the player's bets
mapping(address => player) public players;

// Track the originator and the challengers
address originator;
address challenger;


// The bet amount of the contract is set by the originator. This person is originator.
constructor (
     uint256 _commitPhaseLengthInSeconds
    ,bytes32 _betCommit
    ) 
    public 
    payable 
    {
    require(msg.value > 0 && _commitPhaseLengthInSeconds > 60);
    originator = msg.sender;
    commitPhaseEndTime = now + _commitPhaseLengthInSeconds;
    players[msg.sender]._betCommit = _betCommit;
    pot += msg.value;
}


// Accept the challengers bet commit, ensure the challenger has not already entered and the value matches the betAmount
function challengerCommitBet(
    bytes32 _betCommit
    ) 
    public 
    payable 
    {
    // ensure the challenger's bet matches the originator
    require(msg.value == pot && now < commitPhaseEndTime && challenger == 0);
    challenger = msg.sender;
    pot += msg.value; 
    players[msg.sender]._betCommit = _betCommit; 
}


// Get the senders choice and password to verify their bet 
function revealBets(
     bool _choice
    ,string _password
    ) 
    public 
    {
    // Ensure we're after the commit phase 
    require(now > commitPhaseEndTime);
    if (players[msg.sender]._betCommit == keccak256( _choice, _password)){
     players[msg.sender].choice = _choice;
     players[msg.sender].betStatus = true;
    }
    
}


function revealResult(){
    bool result = keccak256( players[originator]._betCommit, players[challenger]._betCommit ) % 2 ;
    
    
}

}
